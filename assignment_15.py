# -*- coding: utf-8 -*-
"""assignment 15

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qK6RvQj7FscGMSL4MOqxxLOP1GWo_V90
"""

#1solution

def find_next_greater(arr):
    stack = []
    result = [-1] * len(arr)

    for i in range(len(arr)-1, -1, -1):
        while stack and arr[i] >= stack[-1]:
            stack.pop()

        if stack:
            result[i] = stack[-1]

        stack.append(arr[i])

    return result

#2solution

def find_nearest_smaller(a):
    stack = []
    result = [-1] * len(a)

    for i in range(len(a)):
        while stack and a[i] <= stack[-1]:
            stack.pop()

        if stack:
            result[i] = stack[-1]

        stack.append(a[i])

    return result

#3question

from queue import Queue

class Stack:
    def __init__(self):
        self.q1 = Queue()
        self.q2 = Queue()

    def push(self, value):
        # Move all elements from q1 to q2
        while not self.q1.empty():
            self.q2.put(self.q1.get())

        # Add the new element to q1
        self.q1.put(value)

        # Move all elements back from q2 to q1
        while not self.q2.empty():
            self.q1.put(self.q2.get())

    def pop(self):

        if self.q1.empty():
            return None

        # Remove and return the top element from q1
        return self.q1.get()

    def top(self):

        if self.q1.empty():
            return None


        top_element = self.q1.get()
        self.q1.put(top_element)
        return top_element

    def is_empty(self):
        return self.q1.empty()

#4solution
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)


def reverse_stack(stack):
    if not stack.is_empty():
        # Remove the top item from the stack
        item = stack.pop()

        # Reverse the remaining stack
        reverse_stack(stack)

        # Insert the removed item at the bottom of the reversed stack
        insert_at_bottom(stack, item)


def insert_at_bottom(stack, item):
    if stack.is_empty():
        stack.push(item)
    else:
        # Remove all items from the stack and insert the item at the bottom
        temp = stack.pop()
        insert_at_bottom(stack, item)

        # Push the temporarily removed items back onto the stack
        stack.push(temp)



stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)

print("Original Stack:", stack.items)

reverse_stack(stack)

print("Reversed Stack:", stack.items)

#5solution

def reverse_string(string):
    stack = []
    reversed_string = ""

    # Push each character of the string onto the stack
    for char in string:
        stack.append(char)

    # Pop the characters from the stack to form the reversed string
    while stack:
        reversed_string += stack.pop()

    return reversed_string



string = "Hello, World!"
reversed_string = reverse_string(string)
print("Original string:", string)
print("Reversed string:", reversed_string)

#6 solution

def reverse_string(string):
    stack = []
    reversed_string = ""

    # Push each character of the string onto the stack
    for char in string:
        stack.append(char)

    # Pop the characters from the stack to form the reversed string
    while stack:
        reversed_string += stack.pop()

    return reversed_string


# Example usage
string = "Hello, World!"
reversed_string = reverse_string(string)
print("Original string:", string)
print("Reversed string:", reversed_string)

#7solution

class MinStack:
    def __init__(self):
        self.stack = []  # Stack to store the actual elements
        self.min_stack = []  # Stack to store the minimum elements

    def push(self, val):
        self.stack.append(val)  # Push the element onto the actual stack

        # Check if the min stack is empty or if the new element is smaller than or equal to the current minimum
        if len(self.min_stack) == 0 or val <= self.min_stack[-1]:
            self.min_stack.append(val)  # Push the element onto the min stack

    def pop(self):
        # Check if the stack is empty
        if len(self.stack) == 0:
            return

        element = self.stack.pop()  # Pop the element from the actual stack

        # Check if the popped element is the current minimum
        if element == self.min_stack[-1]:
            self.min_stack.pop()  # Pop the element from the min stack

    def top(self):
        # Check if the stack is empty
        if len(self.stack) == 0:
            return None

        return self.stack[-1]
    def getMin(self):
        # Check if the min stack is empty
        if len(self.min_stack) == 0:
            return None

        return self.min_stack[-1]

